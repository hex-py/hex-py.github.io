---
title: consul白皮书.
categories:
  - 提上日程
tags:
  - 运维
  - consul
  - 微服务组件
  - 服务发现
date: '20191120 08:49:00'
sticky: 0
comments: true
---

## 目录

1. Consul 简介
    + 1.1 简介
    + 1.2 功能特点
    + 1.3 术语
    + 1.4 多数据中心服务网络

2. 集群架构
    + 2.1 网络
    + 2.2 节点规划
    + 2.3 安全机制

3. 维护
    + 3.1 高可用
    + 3.2 集群扩容
    + 3.3 服务管理 增删改查 + 健康检查
    + 3.4 配置管理 增删改查
    + 3.5 安全认证
    + 3.6 备份策略

4. 监控
    + 4.1 consul节点状态
    + 4.2 集群 Consul-Server 数
    + 4.3 集群 成员 总数
    + 4.3 集群 成员 状态
    + 4.4 集群注册的 services 数
    + 4.5 集群注册的 services 状态
    + 4.6 节点健康状态
    + 4.7 服务健康状态
    + 4.8 k/v-store 中的值
5. 故障恢复
    + 5.1 日志策略 日志文件过大
6. 其他

## 云和微服务的现在服务网络

欢迎来到领事介绍指南！ 本指南是Consul的最佳起点。 我们将介绍Consul是什么，它可以解决哪些问题，它与现有软件的比较，以及如何开始使用它。 如果您熟悉Consul的基础知识，则文档提供了有关可用功能的更详细参考。

### 1. Consul 简介

#### 1.1 简介

Consul是一种服务网格解决方案，提供具有服务发现配置和分段功能的全功能控制平面。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全服务网格。Consul需要数据平面并支持代理和本机集成模型。Consul附带一个简单的内置代理，因此一切都可以开箱即用，但也支持第三方代理集成，如Envoy。

#### 1.2 功能特点

+ **服务发现：** Consul的客户端可以注册服务，例如api或mysql，其他客户端可以使用Consul来发现给定服务的提供者。 使用DNS或HTTP，应用程序可以轻松找到它们所依赖的服务。
+ **健康检查：** Consul的客户端可以提供任意数量的运行状况检查，这些检查可以与给定服务相关联（“是Web服务器返回 200 OK”），也可以与本地节点（“内存利用率低于90％”）相关联。 企业可以使用此信息来监控群集运行状况，服务发现组件使用该信息将流量路由远离不健康的主机。
+ **键值存储：** 应用程序可以将Consul的分层键/值存储用于任何目的，包括动态配置，功能标记，协调，领导者选举等。配置修改借口是简单的HTTP API，使其更易于使用。
+ **安全的服务访问：** Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。 意图可用于定义允许哪些服务进行通信。 可以使用可以实时更改的意图轻松管理服务分段，而不是使用复杂的网络拓扑和静态防火墙规则。
+ **多数据中心：** Consul支持开箱即用的多个数据中心。 这意味着Consul的用户不必担心构建额外的抽象层以扩展到多个区域。

Consul旨在对DevOps社区和应用开发人员友好，使其成为现代，弹性基础架构的理想选择。

#### 1.3 术语

此小节收集了Consul和Consul Enterprise文档中使用的一些技术术语的简要定义，以及Consul社区中对话中经常出现的一些术语。

##### Agent

Agent是一直运行Consul集群中每个成员上的守护程序。通过运行`consul agent`来启动的。Agent可以运行在Client或者Server模式。由于所有节点都必须运行Agent，指定节点作为client或者server是非常简单的，除非有其他agent实例。所有Agent都可以运行DNS或HTTP接口，并负责运行时检查并保持服务同步。

##### Client

Client是一个转发所有RPC到服务器的Agent。Client是相对无状态的。Client唯一执行的后台活动是加入LAN gossip 池。Client只需要一个最低的资源开销并且仅消耗少量的网络带宽。

##### Server

Server是一个具有扩展功能的Agent，这些功能包括参与Raft选举，维护群集状态，响应RPC查询，与其他数据中心交换WAN-gossip，并将RPC查询转发给leaders或远程数据中心。

##### Datacenter

虽然数据中心的定义是显而易见的，但是有一些细微的细节必须考虑。例如，在EC2中，多个可用区域被认为组成一个数据中心。我们定义数据中心为一个私有的，低延迟和高带宽的一个网络环境。这不包括访问公共网络，但是对于我们而言，同一个EC2中的多个可用区域可以被认为是一个数据中心的一部分。

##### Consensus

一致性，使用Consensus来表示对Raft选举Leader和事务的顺序达成一致。为了以容错方式达成一致，一般有超过半数一致则可以认为整体一致。Consul使用Raft实现一致性，进行leader选举。在consul中的使用bootstrap时，可以进行自选，其他server加入进来后bootstrap就可以取消。

##### Gossip

Consul通过Serf(Serf是出自Hashicorp的开源项目，实现了去中心化的gossip协议。Serf是去中心化的服务发现和编制的解决方案，节点失败侦测与发现，具有容错、轻量、高可用的特点。一些著名的开源项目，如Docker和Consul，网络管理和服务发现的核心组件是基于Serf实现的)，提供了一个用于多播目的的、完整的`gossip protocol`。Serf提供成员关系，故障检测和事件广播。gossip涉及随机节点到节点的通信(主要通过UDP协议)。

##### LAN Gossip

指`LAN Gossip pool`，包含位于同一局域网或数据中心的全部节点。

##### WAN Gossip

指`WAN Gossip pool`，它只包含Server。这些Server主要分布于不同的数据中心，通常通过互联网或广域网通信(跨数据中心服务发现与同步)。

##### RPC

RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

#### 1.4 多数据中心服务网络

Consul提供多云服务网络层来连接和保护服务。Consul是一种广泛部署的产品，许多客户在其环境中运行的节点数量远远超过100,000个。

应集中提供网络服务，从而IT团队提供服务注册和服务发现功能。拥有一个通用注册表可以提供正在运行的服务，它们所在位置以及它们当前健康状态的“映射”。可以通过编程方式查询注册表以启用服务发现或驱动API网关，负载平衡器，防火墙和其他关键中间件组件的网络自动化。可以使用服务网格方法将这些中间件组件移出网络，其中代理在边缘上运行以提供等效功能。服务网格方法允许简化网络拓扑，尤其是对于多云和多数据中心拓扑。

云操作模型中的网络起点通常是常见的服务注册表。这将集成运行状况检查并提供DNS和API接口，以使任何服务能够发现并被其他服务发现。

在复杂的环境中，Consul提供分布式服务网格，以跨任何运行时平台和云连接，保护和配置服务。Consul提供了一个API驱动的控制平面，它与数据平面的代理如Envoy，HAProxy和Nginx集成。 这允许命名，分段和授权以及路由等关键功能由边缘的代理处理，而不是使用集中式中间件。

Consul通过自动TLS加密和基于身份的授权，实现细粒度服务分段，以保证服务到服务的通信。 Consul可以与Vault集成，实现集中式PKI和证书管理。服务配置通过API驱动的Key/Value存储实现，可用于在任何环境中在运行时轻松配置服务。

![](consul-compare.png)<br>

云网络的挑战通常是为企业采用云运营模式最困难的方面之一。动态IP地址的组合，采用微服务模式的东西向流量的显着增长，以及缺乏清晰的网络边界是一项艰巨的挑战。

随着组织扩展其微服务，服务之间的流量呈指数级增长，流量路径变得更加动态。 负载均衡器不是一种可扩展的方法，正如我们在本节之前所说明的那样。 但是，服务发现为管理东西向流量提供了更优雅的方法。

有了服务发现解决方案，所有服务实例在部署时就会注册为中央服务注册表的一部分。 如果服务A需要与服务B通信，它将查询服务注册表，该服务注册表返回所有可用服务实例B的网络位置。通常，这是在没有使用DNS进行代码修改的情况下完成的。 使用丰富的REST API可以启用更高级的用例。

此解决方案还可以通过随机向不同实例发送流量来执行负载平衡。 在这种方法中，路由和负载平衡是完全分布的，这允许系统扩展到非常大的环境中。

在单个数据中心或云区域内，如果其中一个服务实例终止，则注册表将避免返回其地址以触发自动故障转移到其他正常实例。 在数据中心之间，组织可以使用服务发现定义集中式故障转移策略，以自动将流量路由到运行在不同地理位置或云区域的服务实例，这意味着他们不再需要将此逻辑硬编码到应用程序中或管理其他故障转移设备。

![](east-west.png)<br>
一旦服务或资源在服务注册表中自动注册，它就可以发现想要使用该资源或服务并连接它们的其他服务。

### 2. Consul基础架构

Consul是一个分布式、高可用的系统。 本节将介绍基础知识，故意省略一些不必要的细节，以便您快速了解Consul的工作原理。 有关更多详细信息，请参阅[深入的体系结构概述]()。

Consul提供服务的每个节点都运行 Consul-agent。 服务发现、配置kv-store不需要运行agent。agent负责节点上的服务以及节点本身的健康检查。

Consul-Agent与一个或多个Consul-Server通信。 Consul-Server是存储和复制数据的地方。 Consul-Server本身选出了Consul-Leader。 虽然Consul可以单机部署，但建议使用3到5台组成的集群，以避免导致数据丢失的故障情况。 建议为每个数据中心使用Consul集群部署。

当你需要发现自己基础架构中某个服务时，可以查询任何一台Consul-Server或Consul-Agent。Consul-Agent会自动将查询转发给Consul-Server。

每个数据中心都运行Consul集群。当发生跨数据中心服务发现或配置请求时，本地Consul-Server会将请求转发到远端数据中心并返回结果。实现跨数据中心服务发现或配置请求。


#### 2.1 网络

##### 2.1.1 多数据中心部署架构
![](consul-arch.png)<br>

首先，我们可以看到有两个数据中心，标记为“Datacenter1”和“Datacenter2”。Consul为多个数据中心提供服务发现等服务支持。

`Consul Cluster`由部署和运行了`Consul Agent`的节点组成。在Cluster中有两种角色: `Consul Server`和 `Consul Client`。
所有部署运行的`Consul Agent`都在同一个`Gossip pool`这样做有以下几个目的：
1. 不需要为`Consul Client`配置`Consul Server`的地址（通过Gossip protocol自动发现）；
2. 对`Consul Agent`的健康检查不是依靠`Consul Server`，而是分布式的，使得故障加测方案比心跳检测更具拓展性，并且提供了对节点的故障检测；
3. `Consul Agent`作为消息传递层可用于诸如leaders选举等重要事件发生时进行通知。

每个DataCenter中的Server都是单个Raft对等集的一部分。这意味着他们共同选举一个领导者，一个具有额外职责的选定Server。 Server(Leader)负责处理所有查询和交易。作为共识协议的一部分，还必须将事务复制到所有对等体(Server)。由于此要求，当非领导者Server(follower)收到RPC请求时，它会将其转发给群集Server(Leader)。

Server 节点上的`Cluster Agent`也作为`WAN Gossip Pool`的一部分运行。 此池与`LAN Gossip pool`不同，因为它针对较高的Internet延迟进行了优化，并且仅包含其他Consul集群 Server 节点上的`Consul Agent`。 WAN池的目的是允许数据中心以低触摸方式发现彼此。在线创建新的数据中心就像加入现有的`WAN Gossip Pool`一样简单。 由于`Consul Server`都在此池中运行，因此它还支持跨数据中心请求。当`Consul Server`收到不同数据中心的请求时，它会将其转发到正确数据中心的随机`Consul Server`。 然后该`Consul Server`可以将请求转发给本集群领导者`Consul Server(Leader)`。这保证了数据中心之间的耦合非常低，连同故障检测，连接缓存和多路复用等策略，使得跨数据中心请求相对快速且可靠。

通常，不会在不同的`Consul Cluster`之间复制数据。当对另一个数据中心中的service发出请求时，本地`Consul Server`会将RPC请求转发给该service所在的远程`Consul Server`并返回结果。如果远程数据中心不可用，那么这些资源也将不可用，但这不会影响本地数据中心。在某些特殊情况下，可以复制有限的数据子集，例如使用Consul的内置ACL复制功能，或者使用consul-replicate这样的外部工具。

在某些地方，客户端代理可以缓存来自服务器的数据，以使其在本地可用，以提高性能和可靠性。 示例包括连接证书和意图，允许客户端代理在没有往返服务器的情况下做出有关入站连接请求的本地决策。 某些API端点还支持可选的结果缓存。 这有助于提高可靠性，因为本地代理可以继续响应某些查询，例如服务发现或从缓存连接授权，即使与服务器的连接中断或服务器暂时不可用也是如此。

综上所述：
1. `Server`和`Client`的角色和`Consul Cluster`上运行的应用服务无关, 是基于Consul层面的一种角色划分.
2. Consul Server: 用于维护Consul Cluster的状态信息，实现数据一致性，响应RPC请求。运行3到5个Consul Server最佳。多个server之中需要选举一个leader, 这个选举过程Consul基于Raft协议实现. 多个Server节点上的Consul数据信息保持强一致性。
3. LAN GOSSIP：在局域网通信，负责本地客户端与服务端的通讯。
4. WAN GOSSIP：通过广域网与其他数据中心（server）通讯。
5. Consul Client: 只维护自身的状态，并将HTTP和DNS接口请求转发给服务端。
6. Consul 支持多数据中心，多个数据中心要求每个数据中心都要安装一组Consul cluster，多个数据中心间基于gossip protocol协议来通讯，使用Raft算法实现一致性。

#### 2.2 节点规划

`Consul Cluster`是`Client`和`Server`的混合体。`Server`建议在3到5台。这在故障情况下的可用性和性能之间取得了平衡，因为随着添加了更多的机器，共识会变得越来越慢。`Client`的数量没有限制，可以很容易地扩展到成千上万。

|主机名        |IP地址|Consul角色       |NUM|
|-------------|------|----------------|---|
|dev-master-01|      |server(leader)  | 1 |
|dev-node-02  |      |server(follower)| 2 |
|dev-node-03  |      |Client          | n |

#### 2.3 安全机制

Consul依靠轻量级gossip和RPC系统来提供各种功能。这两个系统都有不同的安全机制，这些机制源于他们的设计。 但是，Consul的安全机制有一个共同的目标：提供机密性，完整性和身份验证。Gossip Protocol由`Serf`提供支持，`Serf`使用对称密钥或共享密钥密码系统。RPC系统支持使用端到端TLS和可选的客户端身份验证。 TLS是一种广泛部署的非对称密码系统，是Web安全的基础。这意味着Consul通信可以防止窃听，篡改和欺骗。这使得可以在不受信任的网络（例如EC2和其他共享主机提供商）上运行Consul。

##### 2.3.1 安全配置

Consul默认不启用安全。如下面部分所述，还必须对Consul威胁模型之外的项目采取额外的安全预防措施。

+ **使用默认拒绝启用ACL**。 必须将Consul配置为使用具有白名单（默认拒绝）方法的ACL。 这会强制所有请求具有显式匿名访问权限或提供ACL令牌。

+ **加密已启用**。 必须启用并配置TCP和UDP加密，以防止Consul代理之间的明文通信。 至少应启用verify_outgoing以验证具有唯一TLS证书的每台服务器的服务器真实性。 还需要verify_server_hostname来防止受损代理作为服务器重新启动并被授予对所有机密的访问权限。
verify_incoming通过相互身份验证提供额外的代理验证，但强制威胁模型并非绝对必要，因为请求还必须包含有效的ACL令牌。 细微之处在于，当前verify_incoming = false将允许服务器仍然接受来自客户端的未加密连接（以允许逐步推出TLS）。 仅此一项并未违反威胁模型，但任何选择不使用TLS的配置错误的客户端都将违反该模型。 我们建议将此设置为true。 如果留下，则必须注意确保所有consul客户端使用verify_outgoing = true ，如上所述，但所有外部API / UI访问必须通过HTTPS禁用HTTP侦听器。

除了配置上述非默认设置外，Consul还有几个非默认选项，可能会带来额外的安全风险。

+ **使用网络公开的API启用脚本检查**。 如果`Consul Agent`将其HTTP API暴露给localhost之外的网络，则enable_script_checks必须为false否则即使配置了ACL，脚本检查也会出现远程代码执行威胁。如果必须公开HTTP API, 升级至1.3.0以上版本，enable_local_script_checks提供了一种安全的替代方案。

+ **远程执行启用**。 Consul包含一个consul exec功能，允许跨群集执行任意命令。默认情况下禁用此功能。如果启用，则必须非常小心以确保正确的ACL限制访问。例如，任何管理令牌都授予访问权以在群集上执行任意代码。

+ **验证服务器主机名是否单独使用**。consul从版本0.5.1到1.4.0，存在bug(CVE-2018-19653)，这在1.4.1中得到修复。

### 3. 维护

#### 3.1 高可用
Consul集群化部署即可实现高可用，推荐部署3~5台Server以搭建Consul集群。Consul基于Raft协议实现一致性。

Raft 节点只会存在以下三种角色： Leader、follower、candidate。所有的Raft节点最初的状态都是follower，follower节点可以接受来自Leader的请求并投票。如果在一段时间内没有收到任何消息，则节点状态会由follower提升到candidate。candidate节点会请求来自对等提的投票，如果获得法定数量的投票则变为Leader节点，Leader几点负责write操作写入持久存储，并复制给所有Follower节点。

3个节点的Raft集群可以容忍单个节点故障，而5个集群可以容忍2个节点故障。建议的配置是为每个数据中心运行3或5个Consul服务器。这可以最大限度地提高可用性，而不会大大降低性 下面的部署表总结了潜在的群集大小选项以及每个选项的容错能力

|Servers|Quorum size|failure tolerance|
|-------|-----------|-----------------|
|1      |     1     |       0         |
|2      |     2     |       0         |
|3      |     2     |       1         |
|4      |     3     |       1         |
|5      |     3     |       2         |
|6      |     4     |       2         |
|7      |     4     |       3         |

在性能方面，Raft与Paxos相当。假设稳定的leader，提交日志条目需要一次往返集群的一半。因此，性能受磁盘I/O和网络延迟的限制。尽管Consul并非设计为高吞吐量写入系统，但它应该按照每秒数百到数千个事务的顺序处理，具体取决于网络和硬件配置。

由于所有Server都作为Raft对等集的一部分，因此他们都知道当前的Leader。当RPC请求到达非领导者服务器时，请求将转发给Leader。 如果RPC是查询类，意味着它是只读的，则Leader将根据FSM的当前状态生成结果。如果RPC是事务类型，意味着它修改状态，则领导者做写操作并通过Raft同步给对等集。

由于Raft复制的性质，性能对网络延迟很敏感。出于这个原因，每个数据中心选择一个独立的领导者并维护一个不相交的对等集。 数据由数据中心分区，因此每个领导者仅负责其数据中心中的数据。收到远程数据中心的请求后，请求将转发给正确的领导者。此设计允许更低延迟的事务和更高的可用性，而不会牺牲一致性。

#### 3.2 集群扩容
##### 3.2.1 Consul发现机制

+ 当一个Consul Agent启动后，它并不知道其它节点的存在，它是一个孤立的单节点集群。
+ 如果想感知到其它节点的存在，它必须加入到一个现存的集群。
+ 要加入到一个现存的集群，它只用加入集群中任意一个现存的成员。
+ 当加入一个现存的成员后，会通过成员间的通讯很快发现集群中的其它成员。
+ 一个Consul Agent可以加入任意一个Agent，而不仅仅是Server节点。

##### 3.2.2 Server节点平行扩展 
```bash
# `-server`声明作为服务器模式，
# 192.168.2.212 为当前部署的机器IP
# 192.168.2.210 为目标consul集群任一成员的IP

consul agent -server -syslog \
    -ui \
    -data-dir=/opt/consul/data \
    -config-dir=/opt/consul/conf \
    -pid-file=/opt/consul/run/consul.pid \
    -client=192.168.2.212 \
    -bind=192.168.2.212 \
    -join=192.168.2.210 \
    -node=consul-server03 \
    -disable-host-node-id
```
这里启动的时候就会自动加入一个已有集群，因为启动时加入了`-join`参数，该参数可以自动加入一个已知Consul集群。
如果一个单节点的`Consul Server`已启动, 也可以通过下面命令加入目标consul集群。
```bash
# 在需要加入集群的主机[new-node]上执行 cluster-node-ip 为任一个集群member的ip
consul join --http-addr new-node:8500 cluster-node-ip
```

##### 3.2.3 Client节点平行扩展
```bash
# 在dev-node-03上部署
# 该节点是Client角色，不加`-server`参数声明作为服务器模式，
# 192.168.2.21３ 为当前部署的机器IP
# 192.168.2.210 为目标consul集群任一成员的IP
consul agent -syslog \
    -data-dir=/opt/consul/data \
    -config-dir=/opt/consul/conf \
    -pid-file=/opt/consul/run/consul.pid \
    -client=192.168.2.213 \
    -bind=192.168.2.213 \
    -join=192.168.2.210 \
    -node=consul-client01 \
    -disable-host-node-id
```
跟`Consul Server`扩展命令类似，Client启动的时候就会自动加入一个已有集群，因为启动时加入了`-join`参数，该参数可以自动加入一个已知Consul集群。如果一个单节点的`Consul Client`已启动, 也可以通过下面命令加入目标consul集群。
```bash
# 在需要加入集群的主机[new-node]上执行 cluster-node-ip 为任一个集群member的ip
consul join --http-addr new-node:8500 cluster-node-ip
```

##### 3.2.4 集群状态确认
+ 成功加入集群后，可以通过-join指定的集群的节点日志看出leader已选取出来
```bash
...
    2017/05/10 13:54:37 [INFO] consul: cluster leadership acquired
    2017/05/10 13:54:37 [INFO] consul: New leader elected: consul-server01
    2017/05/10 13:54:37 [INFO] consul: member 'consul-server01' joined, marking health alive
...
```
+ 此时在dev-master-01节点上查看成员状态，彼此都能互识。
```bash
# dev-master-01
$ consul members --http-addr 192.168.2.210:8500
Node             Address             Status  Type    Build  Protocol  DC
consul-server01  192.168.2.210:8301  alive   server  0.8.1  2         dc1
consul-server02  192.168.2.211:8301  alive   server  0.8.1  2         dc1
consul-server03  192.168.2.212:8301  alive   server  0.8.1  2         dc1
```
+ 通过HTTP API方式查询，在三个节点上任意一个节点执行。
```bash
# 查询集群leader
$ curl 192.168.2.210:8500/v1/status/leader
"192.168.2.210:8300"

# 查询集群成员
$ curl 192.168.2.210:8500/v1/status/peers
["192.168.2.210:8300","192.168.2.211:8300","192.168.2.212:8300"]
```
+ 通过DNS方式来查询节点信息
查询结构为NAME.node.consul和NAME.node.DATACENTER.consul。以查询consul-server01为例：
```bash
$ dig @192.168.2.210 -p 8600 consul-server01.node.consul

;; QUESTION SECTION:
;consul-server01.node.consul.	IN	A

;; ANSWER SECTION:
consul-server01.node.consul. 0	IN	A	192.168.2.210

;; Query time: 1 msec
;; SERVER: 192.168.2.210#8600(192.168.2.210)
;; WHEN: Wed May 10 16:54:08 CST 2017
;; MSG SIZE  rcvd: 61

$ dig  @192.168.2.210 -p 8600 consul-server01.node.dc1.consul

;; QUESTION SECTION:
;consul-server01.node.dc1.consul. IN	A

;; ANSWER SECTION:
consul-server01.node.dc1.consul. 0 IN	A	192.168.2.210

;; Query time: 0 msec
;; SERVER: 192.168.2.210#8600(192.168.2.210)
;; WHEN: Wed May 10 16:55:50 CST 2017
;; MSG SIZE  rcvd: 65
```

##### 3.2.5 注意事项
+ 如果有多个成员，也只用加入一个节点，其它节点会在这个节点加入集群后通过成员间的通讯相互发现。
+ 确保所有节点TCP或UDP的8301是开放的，节点间的通讯得依赖这个端口，否则无法加入。
+ 确保所有节点TCP的8300是开放的，因为Client向Server的RPC得依赖这个端口，不打开无法同步。

##### 3.2.6 脱离集群

可以使用`Ctrl-C`来平滑退出，也可以强行`Kill`退出。区别是主动告知其它节点自己的离开，和被其它节点标记为失效。这里要注意，在集群中平滑退出是很重要的。

#### 3.3 服务管理

##### 3.3.1 服务注册
Consul进行服务注册提供了两种方式(`HTTP API`以及配置文件指定)，在这里我们使用`HTTP API`的方式:

+ agent endpoints用来和本地agent进行交互，一般用来服务注册和检查注册，支持以下接口

```bash
/v1/agent/checks : 返回本地agent注册的所有检查[包括配置文件和HTTP接口]
/v1/agent/services : 返回本地agent注册的所有 服务
/v1/agent/members : 返回agent在集群的gossip pool中看到的成员
/v1/agent/self : 返回本地agent的配置和成员信息
/v1/agent/join/<address> : 触发本地agent加入node
/v1/agent/force-leave/<node>>: 强制删除node
/v1/agent/check/register : 在本地agent增加一个检查项,使用PUT方法传输一个json格式的数据
/v1/agent/check/deregister/<checkID> : 注销一个本地agent的检查项
/v1/agent/check/pass/<checkID> : 设置一个本地检查项的状态为passing
/v1/agent/check/warn/<checkID> : 设置一个本地检查项的状态为warning
/v1/agent/check/fail/<checkID> : 设置一个本地检查项的状态为critical
/v1/agent/service/register : 在本地agent增加一个新的服务,使用PUT方法传输一个json格式的数据
/v1/agent/service/deregister/<serviceID> : 注销一个本地agent的服务项
```
+ catalog endpoints用来注册/注销nodes、services、checks

|endpoint                     | description                            |
|-----------------------------|----------------------------------------|
|/v1/catalog/register         | Registers a new node, service, or check|
|/v1/catalog/deregister       | Deregisters a node, service, or check  |
|/v1/catalog/datacenters      | Lists known datacenters                |
|/v1/catalog/nodes            | Lists nodes in a given DC              |
|/v1/catalog/services         | Lists services in a given DC           |
|/v1/catalog/service/<service>| Lists the nodes in a given service     |
|/v1/catalog/node/<node>      | Lists the services provided by a node  |

##### 3.3.2 健康检查
health endpoints用来查询健康状况相关信息，该功能从catalog中单独分离出来

|endpoint                     | description|
|-----------------------------|----------------------------------------|
|/v1/healt/node/<node>        | 返回node所定义的检查，可用参数?dc=         |
|/v1/health/checks/<service>  | 返回和服务相关联的检查，可用参数?dc=   　 　|
|/v1/health/service/<service> | 返回给定datacenter中给定node中service    |
|/v1/health/state/<state>     | 返回给定datacenter中指定状态的服务，state可以是"any", "unknown", "passing", "warning", or "critical"，可用参数?dc=|


#### 3.4 配置管理 增删改查
利用Consul的 K/V-Store 来存储配置 /kv endpoints用来查询、创建、修改K/V-Store中的数据。

|endpoint                     | description                   |
|-----------------------------|-------------------------------|
|/v1/kv/:key                  | Read/Create/Update/Delete  Key|

##### 3.4.1 获取配置

| Method |     Path    |    Produces      | Acl Required | Blocking Queries	|
|--------|-------------|------------------|--------------|------------------|
|  Get   | /v1/kv/:key | application/json |   key:read   |      YES         |
Parameters
+ key     [string: ""] - 指定索要获取的`key`的路径。
+ dc      [string: ""] - 指定所要查询的数据中心。
+ keys    [bool: false] - 只返回key的list,不带value和元数据。
+ raw     [bool: false] - 只返回该key的原始值,不带编码和元数据。
简单示例如下：
```bash
$ curl \
    http://127.0.0.1:8500/v1/kv/my-key
```
Response
```json
[
  {
    "CreateIndex": 100,
    "ModifyIndex": 200,
    "LockIndex": 200,
    "Key": "zip",
    "Flags": 0,
    "Value": "dGVzdA==",
    "Session": "adf4238a-882b-9ddc-4a9d-5b6758e4159e"
  }
]
```
+ CreateIndex 是创建该条记录的索引。
+ ModifyIndex 是修改此key的最后一次索引。
+ LockIndex 在锁中成功获取此密钥的次数。
+ key 是key的完整路径。
+ Flags 是一个不透明的无符号整数，可以附加到每个key。
+ Value 是base64编码的数据块

Keys Response
当使用`?keys`请求参数是，返回值的结构会发生变化，变成一个数组json对象
```json
[
  "/my-key/bar",
  "/my-key/foo",
  "/my-key/subdir/"
]
```

##### 3.4.2 创建、修改配置

| Method |     Path    |    Produces      | Acl Required | Blocking Queries	|
|--------|-------------|------------------|--------------|------------------|
|  PUT   | /v1/kv/:key | application/json |  key:write   |      NO          |
Parameters
+ key     [string: ""] - 指定索要获取的`key`的路径。
+ dc      [string: ""] - 指定所要查询的数据中心。
+ keys    [bool: false] - 只返回key的list,不带value和元数据。
+ raw     [bool: false] - 只返回该key的原始值,不带编码和元数据。
简单示例如下：
```bash
curl \
    --request PUT \
    --data @contents \
    http://127.0.0.1:8500/v1/kv/my-key
# or

curl \
    --request PUT \
    --data-binary @contents \
    http://127.0.0.1:8500/v1/kv/my-key
```
Keys Response
```json
true
```

##### 3.4.3 删除配置

| Method |     Path    |    Produces      | Acl Required | Blocking Queries	|
|--------|-------------|------------------|--------------|------------------|
| DELETE | /v1/kv/:key | application/json |  key:write   |      NO          |

简单示例如下：
```bash
$ curl \
    --request DELETE \
    http://127.0.0.1:8500/v1/kv/my-key
```
Keys Response
```json
true
```

#### 3.5 安全认证
Consul使用访问控制列表(ACL)来保护UI，API，CLI，服务通信和代理通信。在核心，ACL通过将规则分组到策略中，然后将一个或多个策略与令牌相关联来运行。以下文档和指南将帮助您了解和实施ACL。

Consul和其他系统ACL的区别：
+ 通常的ACL授权例如etcd使用用户名:密码对的方式来认证用户，用户名是可能是公开的，密码是保密的用户自己知道；但是consul没有使用用户名:密码对的方式，就使用一个token值；那么既然只有一个值，就必须注意保密，不能使用约定的名字字符串，例如root, tom, jerry等，因为别人很容易猜出来，现在consul使用的字符串时UUID，既唯一又随机，不能被猜出来。
+ consul的三类权限类型
    + read： 读
    + write： 读和写
    + deny： 不能访问，既不能读也不能写了。

##### 3.5.1 激活ACL
consul的ACL激活需要在所有的consul节点上，办法是，创建一个json格式的配置文件：

```
$ cat consul-acl.json 
{
  "acl" : {
    "enabled" : true,
    "default_policy" : "deny",
    "down_policy" : "extend-cache",
    "tokens" :{
        "master": "245d0a09-7139-bbea-aadc-ff170a0562b1"
    }
  }
}
```
放置到consul agent通过参数-config-dir指定的目录下面，缺省目录是：/consul/config/
注意几点：
1. 这个相同的文件需要部署到所有的consul节点上。
2. 关于tokens.master值，这个就是Bootstrap Token
    + 2.1. Bootstrap Token相当于Unix系统中的root，具有所有的权限。
    + 2.2. 其名字可以是任意字符串，不一定是一个UUID值。(原因如前面说，使用UUID为了安全用户无法猜测。)
    + 2.3. tokens.master可以不需要配置，然后在clustor启动之后通过命令产生，如下：
    ```bash
    $ consul acl bootstrap
    AccessorID:   0274a9e3-1349-78d7-fc53-3dd6f7886626
    SecretID:     245d0a09-7139-bbea-aadc-ff170a0562b1
    Description:  Bootstrap Token [Global Management]
    Local:        false
    Create Time:  2019-01-15 06:21:17.335464249 +0000 UTC
    Policies:
       00000000-0000-0000-0000-000000000001 - global-management
    ```
此时产生的bootstrap就是字符串SecretID: 245d0a09-7139-bbea-aadc-ff170a0562b1。
注意这个bootstrap token的安全不能外泄，不能丢失，后面的创建其他token都需要用到它。

##### 3.5.2 token的三种类型
+ management token: 具有root权限的token，前面介绍的master token就属于这类。也可以增加新的management token。
+ client token: 针对客户端的token，ACL的权限管理主要是针对这类token；当创建client token时需要一个management token。
+ anonymous token: 这是系统内置的token。
##### 3.5.3 创建一个management token
```bash
$ curl \
    -H "X-Consul-Token: secret" \
    -X PUT \
    -d '{"Name": "dc1", "Type": "management"}' \
    http://localhost:8500/v1/acl/create?token=245d0a09-7139-bbea-aadc-ff170a0562b1

{"ID":"7fa04e1d-1b75-81b0-52d3-e311ad3c28f7"}
```
请求头中的参数`X-Consul-Token`的token就是ACL初始化生成的bootstrap token。返回的json对象中的ID即是新生成的`management token`(7fa04e1d-1b75-81b0-52d3-e311ad3c28f7)，具有"root"的权限。

##### 3.5.４ 创建一个client token
client token才是真正需要对其授权的token。创建一个client token需要两步，先创建client policy，然后才能创建client token。
+ 创建client policy
```bash
$ cat client-policy.json 
{
  "Name": "client-read-policy",
  "Description": "Grants read access to all node information",
  "Rules": "node_prefix \"\" { policy = \"read\"}",
  "Datacenters": ["dc1"]
}

$ curl --request PUT --data @client-policy.json http://127.0.0.1:8500/v1/acl/policy?token=753cc134-36c5-e4ea-6abd-56f8b8b8aa7f
{
  "ID":"778192cf-5459-a6e0-99d6-74919ea61dfc",
  "Name":"client-read-policy",
  "Description":"Grants read access to all node information",
  "Rules":"key_prefix \"\" { policy = \"read\"}",
  "Datacenters":["dc1"],
  "Hash":"0lcW+0xrcZ6OxTwb3ND+7oA+FF8XhXj60J8KGFpEZI0=",
  "CreateIndex":105,
  "ModifyIndex":105
}

$ curl -X GET http://127.0.0.1:8500/v1/acl/policies?token=753cc134-36c5-e4ea-6abd-56f8b8b8aa7f
[
    {
        "CreateIndex": 4,
        "Datacenters": null,
        "Description": "Builtin Policy that grants unlimited access",
        "Hash": "swIQt6up+s0cV4kePfJ2aRdKCLaQyykF4Hl1Nfdeumk=",
        "ID": "00000000-0000-0000-0000-000000000001",
        "ModifyIndex": 4,
        "Name": "global-management"
    },
    {
        "CreateIndex": 105,
        "Datacenters": ["dc1" ],
        "Description": "Grants read access to all node information",
        "Hash": "0lcW+0xrcZ6OxTwb3ND+7oA+FF8XhXj60J8KGFpEZI0=",
        "ID": "778192cf-5459-a6e0-99d6-74919ea61dfc",
        "ModifyIndex": 105,
        "Name": "client-read-policy"
    }
]
```
注意这里client-policy.json里面Rules可以为node_prefix, service_prefix，和key_prefix；在我这个例子中只使用了key_prefix因为我们只需要KV访问，没有service discover功能。

+ 创建client token

```bash
$ cat client-token.json 
{
   "Description": "client read token",
   "Policies": [
      {
         "Name": "client-read-policy"
      }
   ],
   "Local": false
}

$ curl --request PUT --data @client-token.json http://127.0.0.1:8500/v1/acl/token?token=753cc134-36c5-e4ea-6abd-56f8b8b8aa7f
{
    "AccessorID": "25be308f-43c0-11c8-e620-117e6b91629d",
    "CreateIndex": 115,
    "CreateTime": "2019-01-15T08:00:04.241925426Z",
    "Description": "client read token",
    "Hash": "AZ2/M3PRNDcTULjWcpC8eb6EPVoGUHnCKa0nQghKN0I=",
    "Local": false,
    "ModifyIndex": 115,
    "Policies": [
        {
            "ID": "778192cf-5459-a6e0-99d6-74919ea61dfc",
            "Name": "client-read-policy"
        }
    ],
    "SecretID": "23fe12e4-ac0e-00af-db43-887589f87823"
}

$ curl -X GET http://127.0.0.1:8500/v1/acl/tokens?token=753cc134-36c5-e4ea-6abd-56f8b8b8aa7f
[
    {
        "AccessorID": "25be308f-43c0-11c8-e620-117e6b91629d",
        "CreateIndex": 115,
        "CreateTime": "2019-01-15T08:00:04.241925426Z",
        "Description": "client read token",
        "Hash": "AZ2/M3PRNDcTULjWcpC8eb6EPVoGUHnCKa0nQghKN0I=",
        "Local": false,
        "ModifyIndex": 115,
        "Policies": [
            {
                "ID": "778192cf-5459-a6e0-99d6-74919ea61dfc",
                "Name": "client-read-policy"
            }
        ]
    },
    ...
]
```

也可以直接将policy和token同时创建
```bash
$ cat client-write-policy.json
{                      
  "Name": "client-write-policy",
  "Description": "Grants write access to foo key information",
  "Type": "client",
  "Rules": "key \"foo/test\" { policy = \"write\" }"
}

$ curl --request PUT --data @client-write-policy.json \
  http://127.0.0.1:8500/v1/acl/create?token=753cc134-36c5-e4ea-6abd-56f8b8b8aa7f
{"ID":"1c7c1ca0-d5ee-9d02-f7f4-89dc8759f0c6"}

$ curl -H "X-Consul-Token: 1c7c1ca0-d5ee-9d02-f7f4-89dc8759f0c6" http://127.0.0.1:8500/v1/acl/token/self
{
    "AccessorID": "808d69bf-c4fe-0c9f-9a57-aecd85e7f24e",
    "CreateIndex": 36,
    "CreateTime": "0001-01-01T00:00:00Z",
    "Description": "client-write-policy",
    "Hash": "mpZmxlI5Zi6HeMFQR0A7U77ZD9IKPDr9Nc9Hrqxz/b8=",
    "Local": false,
    "ModifyIndex": 37,
    "Policies": null,
    "Rules": "key \"foo/test\" { policy = \"write\" }",
    "SecretID": "1c7c1ca0-d5ee-9d02-f7f4-89dc8759f0c6"
}
```

##### 3.5.5 客户端测试
验证，创建一个KV，然后使用client token访问KV：

```bash
$ curl --request PUT --data 'hello consul' http://127.0.0.1:8500/v1/kv/foo?token=753cc134-36c5-e4ea-6abd-56f8b8b8aa7f

$ curl --request GET http://127.0.0.1:8500/v1/kv/foo?token=23fe12e4-ac0e-00af-db43-887589f87823
echo[{"LockIndex":0,"Key":"foo","Flags":0,"Value":"aGVsbG8gY29uc3Vs","CreateIndex":14,"ModifyIndex":14}]

# suppose another token does not have priviledge
curl --request GET http://127.0.0.1:8500/v1/kv/foo?token=477ef15e-79b3-8481-b7db-ed7c750b3bea
rpc error making call: rpc error making call: Permission denied
```

#### 3.6 备份策略


### 4. 监控

#### 4.1 consul节点状态

#### 4.2 集群 Consul-Server 数

#### 4.3 集群 成员 总数

#### 4.3 集群 成员 状态

#### 4.4 集群注册的 services 数

#### 4.5 集群注册的 services 状态

#### 4.6 节点健康状态

#### 4.7 服务健康状态

#### 4.8 k/v-store 中的值

### 5. 故障恢复

#### 5.1 日志策略 日志文件过大

```bash
curl \ --request PUT \ --data-binary @snapshot \ http://127.0.0.1:8500/v1/snapshot 
```













### 升级
Consul是参与Consul集群的任何节点上的长期代理。这些节点始终相互通信。因此，协议级别的兼容性和易于升级是使用Consul时要记住的重要事项。

本小节记录如何升级Consul。

#### 标准升级

对于升级，我们努力确保向后兼容性。为了支持这一点，节点对等存储他们的协议版本和构建。这使客户端和服务器能够智能地启用新功能，或者优雅地回退到向后兼容的操作模式。

对于大多数升级过程，这个过程比较简单。假设当前Consul版本为A，最新发布版本为B。

1. 检查版本的升级说明，确保不存在会影响工作负载的兼容性问题。

2. 在每台服务器上，安装Consul的B版。

3. 一次一台服务器，通过 `consul leave` 关掉版本A并使用版本B重新启动。等待服务器运行正常并重新加入群集，然后再转到下一台服务器。

4. 一旦所有服务器都升级了，就可以按照相同的过程开始Consul-Agent的部署。

5. 升级校验。您可以通过运行`Consul Members`来验证，以确保所有成员都拥有最新的构建版本和最高的协议版本。


#### 非向后兼容升级

在某些情况下，可能会释放向后不兼容的更新。这还不是问题，但为了支持升级，我们支持设置显式协议版本。这将禁用不兼容的功能并启用两阶段升级。


#### 小结

通过运行以前的协议版本，Consul的某些功能（尤其是较新的功能）可能无法使用。 如果是这种情况，Consul通常会警告您。 通常，应始终升级群集，以便运行最新的协议版本。

服务发现已成为微服务和多云服务网络的既定核心组件。 它充当您的网络和监控操作的大脑，在您的服务组合扩展时简化它们。 有许多服务发现工具以不同的方式解决这个问题。 HashiCorp Consul提供全面的服务发现功能，不仅提供服务注册表，还提供分布式运行状况检查，安全性，高可用性，可扩展性，多数据中心/云以及裸机，虚拟化和容器化环境的全面支持，包括所有主要操作系统。

Consul成功地加速了公司的云计算和微服务采用之旅 。 它为服务发现提供了稳定，灵活且经过实战考验的解决方案，中央服务注册表提供应用程序可见性，动态路由和网络自动化。 服务发现不再使应用程序适应网络基础架构，而是使网络满足应用程序的需求，消除了使网络和关键中间件保持最新所需的缓慢手动过程，并用自助服务自动化替换这些过程。


### 参考连接

[Consul operate](http://www.liangxiansen.cn/2017/04/06/consul/)<br>
[Consul Architecture](https://www.hi-linux.com/posts/28048.html)<br>
[Consul ACL](https://www.jianshu.com/p/27a32327eef4)<br>

[Monitor Consul with telegraf](https://learn.hashicorp.com/consul/integrations/telegraf)
[Monitor Consul with statsd exporter](https://werner-dijkerman.nl/2017/05/27/monitoring-consul-with-statsd-exporter-and-prometheus/)